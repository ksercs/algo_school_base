#include <iostream>
#include <fstream>
#include <algorithm>
#include <string>
#include <cmath>
#include <vector>
#include <iomanip>
#include <set>
#include <map>
#include <utility>
#include <queue>
#include <string.h>
#include <cstdlib>

#define SZ size()
#define VEC vector
#define PB push_back
#define MP make_pair
#define SS second
#define FF first
#define PII pair <int,int>
#define LL long long

using namespace std;

ifstream in ("A.in");
ofstream out("A.out");

// Определение узла декартового дерева
struct Node
{
    int x; // Хранимый ключ
    int y; // "Порядок" вершины
    int sz; // Размер поддерева (количество узлов, находящихся ниже данного)
    Node *l, *r; // Указатели на потомков данного узла

    // Конструктор узла (объявлен в описании самой структуры для простоты)
    Node(int _x)
    {
        x = _x;
        y = rand();
        sz = 1;
        l = r = NULL;
    }
    Node() {}
};

// Прототипы функций для работы с размером поддерева - их реализуем ниже.
int get_sz(Node *t);
void update(Node *t);

// --- Основные операции - слияние (merge) и разделение (split) деревьев
// Важно! При выполнении этих операций исходные деревья могут перестать быть
// валидными!

// Слияние двух деревьев (t1, t2). Работает корректно тогда и только тогда,
// когда max(t1) < min(t2). Результат - корень нового дерева.
Node* merge(Node *t1, Node *t2)
{
    // Пустое дерево - то, у которого корень - NULL.
    // Считаем, что слияние дерева с пустым деревом - это исходное дерево.
    if (t1 == NULL) return t2;
    if (t2 == NULL) return t1;

    // Дерево с большим значением y становится новым корнем
    if (t1->y > t2->y){
        // Сливаем правое поддерево первого дерева со вторым деревом и ставим
        // результат в правое поддерево первого дерева.
        t1->r = merge(t1->r, t2);
        // Поскольку теперь дерево t1 поменялось, запускаем в нём обновление.
        update(t1);
        // Новый корень дерева - t1.
        return t1;
    }
    else{
        // Сливаем всё первое дерево с левым поддеревом второго дерева
        // (обязательно именно в таком порядке!!) и ставим результат в левое поддерево
        // второго дерева.
        t2->l = merge(t1, t2->l);
        // Пересчитываем значение в новом корне дерева
        update(t2);
        return t2;
    }
}

// Разделение дерева на два по заданному ключу. После этого в первом дереве
// будут значения (-inf, x), во втором - [x, +inf)
void split(Node *t, int x, Node *&t1, Node *&t2)
{
    // Пустое дерево будет в любом случае разделено на два пустых поддерева
    if (t == NULL){
        t1 = t2 = NULL;
        return;
    }
    // Если текущая вершина содержит значение, меньшее, чем заданное,
    // то она отправляется в первое дерево. Правое поддерево данной вершины
    // в принципе может оказаться больше или равно x, так что его тоже разрезаем,
    // и записываем первое дерево-результат на его место.
    if (t->x < x){
        split(t->r, x, t->r, t2);
        t1 = t;
    }
    else{
        // В противном случае "режем" левое поддерево. Рассуждения остаются такими
        // же (текущая вершина отправляется во второе дерево-результат)
        split(t->l, x, t1, t->l);
        t2 = t;
    }
    // В процессе отрезания мы модифицируем дерево, поэтому для данной вершины надо
    // пересчитать хранимое выражение
    update(t);
}

// Получение размера поддерева
int get_sz(Node *t)
{
    // Размер пустых деревьев считаем равным нулю
    if (t == NULL) return 0;
    // У непустых поддеревьев размер хранится в корне
    return t->sz;
}

// Обновление размера поддерева
void update(Node *t)
{
    // Размер обновляем только для непустых деревьев
    if (t != NULL)
        t->sz = 1 + get_sz(t->l) + get_sz(t->r);
}


// Добавление нового элемента x в дерево t. Корень дерева может измениться!
void add(Node *&t, int x)
{
    Node *t1, *t2;
    // Для добавления делаем следующее:
    // - Разрезаем исходное дерево по ключу x. В левом поддереве все элементы меньше x,
    //   в правом - не меньше.
    split(t, x, t1, t2);
    // - Создаём новое дерево из одной вершины - собственно, x.
    Node* new_tree = new Node(x);
    // - Производим слияние левого поддерева с новым, потом слияние результата с правым
    //   Результат слияния - новый корень дерева.
    t = merge(merge(t1, new_tree), t2);
}

// Удаление вершины из дерева. В данном случае работать будет только с целыми числами!
void remove(Node *&t, int x)
{
    Node *t1, *t2, *t3, *t4;
    // Для удаления делаем следующее:
    // - Разрезаем исходное дерево по ключу x.
    split(t, x, t1, t2);
    // - Разрезаем правое поддерево по ключу x + 1 (вот зачем нужны были целые числа!)
    split(t2, x + 1, t3, t4);
    // - Соединяем деревья t1 и t4, которые теперь не содержат ключа x
    //   (он остался в дереве t3)
    t = merge(t1, t4);
    // - Очищаем память, занимаемую деревом t3 (если не хотим утечек)
    delete t3;
}

// Вывод элементов дерева на экран в отсортированном порядке (обход ЛКП)
void print(Node *t)
{
    // У пустых деревьев выводить нечего
    if (t != NULL){
        // Сначала выводим всё из левого поддерева, затем то, что хранится в
        // корне, затем всё из правого поддерева
        print(t->l);
        cout << t->x << " ";
        print(t->r);
    }
}

// Получение элемента, стоящего на k-м месте в дереве
int get_k(Node *t, int k)
{
    if (k < get_sz(t->l))
        return get_k(t->l, k);
    else if (k == get_sz(t->l))
            return t->x;
        else
            return get_k(t->r, k - get_sz(t->l) - 1);
}

int n;
string s;

int main() {
    Node *treap = NULL;
    while (in >> s >> n)
    {
        if (s == "insert")
            add(treap, n);
        if (s == "delete")
            remove(treap, n);
        if (s == "exists"){
            Node *t1, *t2, *t3, *t4;
            split(treap, n, t1, t2);
            split(t2, n + 1, t3, t4);
            if (t3 == NULL) out << "false\n";
            else            out << "true\n";
            treap = merge(t1, merge(t3, t4));
        }
    }
    return 0;
}
